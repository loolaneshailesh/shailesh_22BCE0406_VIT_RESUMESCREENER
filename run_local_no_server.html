<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸš€</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale-1.0" />
    <title>Smart Resume Screener (Standalone)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&display=swap" rel="stylesheet">
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'space-primary': '#0e7490', // Deep Cyan
              'space-secondary': '#be185d', // Deep Pink/Magenta
              'space-accent': '#6d28d9', // Deep Violet
              'brand-primary': '#0891b2',
              'brand-secondary': '#db2777',
            },
            fontFamily: {
              sans: ['"Exo 2"', 'sans-serif'],
            },
            textShadow: {
              'glow': '0 0 8px var(--tw-shadow-color)',
            },
            boxShadow: {
              'glow': '0 0 15px var(--tw-shadow-color)',
              'glow-lg': '0 0 25px var(--tw-shadow-color)',
            },
            keyframes: {
              'pulse-glow': {
                '0%, 100%': { opacity: 1, boxShadow: '0 0 15px var(--tw-shadow-color)' },
                '50%': { opacity: 0.8, boxShadow: '0 0 25px var(--tw-shadow-color)' },
              }
            },
            animation: {
              'pulse-glow': 'pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            }
          },
        },
        plugins: [
          function({ addUtilities, theme }) {
            const newUtilities = {
              '.text-shadow-glow': {
                textShadow: theme('textShadow.glow'),
              },
            }
            addUtilities(newUtilities, ['responsive', 'hover'])
          }
        ],
      }
    </script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/generative-ai",
        "pdfjs-dist": "https://esm.sh/pdfjs-dist@4.4.168"
      }
    }
    </script>
</head>
<body class="bg-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";
      import * as pdfjsLib from 'pdfjs-dist';

      // --- SETUP ---
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.worker.mjs`;

      // --- ICONS (Components) ---
      const ClockIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
      );
      const HistoryIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M1 4v6h6" />
          <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" />
        </svg>
      );
      const TrashIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          <line x1="10" y1="11" x2="10" y2="17"></line>
          <line x1="14" y1="11" x2="14" y2="17"></line>
        </svg>
      );
      const SparklesIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M12 3L9.5 8.5L4 11L9.5 13.5L12 19L14.5 13.5L20 11L14.5 8.5L12 3Z"/>
          <path d="M5 21L6.5 18"/>
          <path d="M17.5 18L19 21"/>
          <path d="M21 5L18 6.5"/>
          <path d="M3 5L6.5"/>
        </svg>
      );
      const LightbulbIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M15.09 16.05A6.49 6.49 0 0 0 12 10c-1.84 0-3.53.77-4.74 2.06" />
          <path d="M12 2a7 7 0 0 0-7 7c0 2.22 1.02 4.22 2.62 5.51" />
          <path d="M16.38 17.51A7 7 0 0 0 19 12a7 7 0 0 0-7-7" />
          <path d="m5 21 1-1" />
          <path d="m18 21 1-1" />
          <path d="M12 18v3" />
          <path d="M8 21h8" />
        </svg>
      );
      const SendIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <line x1="22" y1="2" x2="11" y2="13"></line>
          <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
      );
      const ClipboardIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
          <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
        </svg>
      );
      const PlusIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      );
      const LoadingSpinner = () => (
        <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" style={{color: 'currentColor'}}>
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      );

      // --- SERVICES ---
      const fileParsers = (() => {
        async function parseTxt(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target?.result);
            reader.onerror = () => reject(new Error("Failed to read the text file."));
            reader.readAsText(file);
          });
        }
        async function parsePdf(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const arrayBuffer = e.target?.result;
                if (!arrayBuffer) {
                    return reject(new Error('Failed to read PDF file into buffer.'));
                }
                const typedArray = new Uint8Array(arrayBuffer);
                const pdf = await pdfjsLib.getDocument(typedArray).promise;
                let fullText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                  const page = await pdf.getPage(i);
                  const textContent = await page.getTextContent();
                  const pageText = textContent.items.map(item => ('str' in item ? item.str : '')).join(' ');
                  fullText += pageText + '\n\n';
                }
                resolve(fullText);
              } catch (error) {
                console.error('Error parsing PDF:', error);
                reject(new Error('Failed to parse PDF content. The file might be corrupted or protected.'));
              }
            };
            reader.onerror = () => reject(new Error('Failed to read the PDF file.'));
            reader.readAsArrayBuffer(file);
          });
        }
        return {
          async parseFile(file) {
            const extension = file.name.split('.').pop()?.toLowerCase();
            if (extension === 'txt' || file.type === 'text/plain') return parseTxt(file);
            if (extension === 'pdf' || file.type === 'application/pdf') return parsePdf(file);
            throw new Error(`Unsupported file type: '${extension}'. Please upload a .txt or .pdf file.`);
          }
        };
      })();

      const geminiService = (() => {
        let ai;
        const candidateSchema = {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              id: { type: Type.STRING }, name: { type: Type.STRING },
              matchScore: { type: Type.INTEGER }, justification: { type: Type.STRING },
              extractedSkills: { type: Type.ARRAY, items: { type: Type.STRING } },
              extractedExperienceSummary: { type: Type.STRING }
            },
            required: ['id', 'name', 'matchScore', 'justification', 'extractedSkills', 'extractedExperienceSummary']
          }
        };

        const callApi = async (model, body) => {
          if (!ai) throw new Error("API key not initialized. Please set your API key first.");
          try {
            const response = await ai.models.generateContent({ model, ...body });
            return response;
          } catch (error) {
              console.error("Gemini API Error:", error);
              const message = error.message || "An unknown error occurred with the Gemini API.";
              if (message.includes("API key not valid")) {
                  throw new Error("The provided API key is not valid. Please check the key and try again.");
              }
              if (message.includes("billing")) {
                  throw new Error("There may be a billing issue with your Google Cloud project. Please ensure billing is enabled.");
              }
              throw new Error(message);
          }
        };
        
        const callApiStream = async (model, body) => {
          if (!ai) throw new Error("API key not initialized. Please set your API key first.");
          try {
            const response = await ai.models.generateContentStream({ model, ...body });
            let text = "";
            for await (const chunk of response) {
                text += chunk.text;
            }
            return text;
          } catch (error) {
              // Handle stream errors, similar to non-stream
              console.error("Gemini API Stream Error:", error);
              throw new Error(error.message || "An unknown streaming error occurred.");
          }
        };


        return {
          initialize: (apiKey) => {
            if (apiKey) ai = new GoogleGenAI({ apiKey });
            else ai = null;
          },
          verifyApiKey: async () => {
              if (!ai) throw new Error("API Key not provided.");
              await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: 'hello' });
          },
          analyzeResumes: async (jobDescription, resumes) => {
            const resumeTexts = resumes.map(r => `--- RESUME START ---\nID: ${r.id}\nFILENAME: ${r.fileName}\n\n${r.text}\n--- RESUME END ---`).join('\n\n');
            const prompt = `You are an expert technical recruiter... JOB DESCRIPTION:\n${jobDescription}\n\nRESUMES TO ANALYZE:\n${resumeTexts}\n\nINSTRUCTIONS: Your output MUST conform to the JSON schema provided.`;
            const response = await callApi('gemini-2.5-flash', {
              contents: [{ parts: [{ text: prompt }] }],
              config: { responseMimeType: "application/json", responseSchema: candidateSchema }
            });
            return JSON.parse(response.text);
          },
          askQuestionAboutResume: (resumeText, question, jobDescription) => {
            const prompt = `You are an expert career coach... JOB DESCRIPTION CONTEXT:\n${jobDescription}\n\nCANDIDATE'S RESUME:\n${resumeText}\n\nUSER'S QUESTION:\n${question}\n\nYOUR INSIGHTFUL ANSWER:`;
            return callApiStream('gemini-2.5-flash', { contents: [{ parts: [{ text: prompt }] }] });
          },
          askConsultant: (jobDescription, resumes, messages) => {
            const resumeFileNames = resumes.map(r => r.fileName).join(', ') || 'None';
            const conversationHistory = messages.map(msg => `${msg.role}: ${msg.content}`).join('\n');
            const prompt = `You are an AI-powered consultant... CONTEXT:\n- Job Description: ${jobDescription || 'Not provided.'}\n- Resumes: ${resumeFileNames}\n- History:\n${conversationHistory}\n\nAnswer the last message.`;
            return callApiStream('gemini-2.5-flash', { contents: [{ parts: [{ text: prompt }] }] });
          },
          generateResumeFromDetails: (data) => {
            const experience = data.workExperience.map(e => `Company: ${e.company}\nTitle: ${e.jobTitle}\nDates: ${e.startDate} - ${e.endDate}\nResponsibilities:\n${e.responsibilities}`).join('\n\n');
            const education = data.education.map(e => `School: ${e.school}\nDegree: ${e.degree}\nDates: ${e.startDate} - ${e.endDate}`).join('\n\n');
            const prompt = `You are a professional resume writer... USER DATA:\n- Name: ${data.fullName}\n- Contact: ${data.email}, ${data.phoneNumber}, ${data.address}\n- Summary: ${data.summary}\n- Experience:\n${experience}\n- Education:\n${education}\n- Skills: ${data.skills}\n\nGenerate the complete resume.`;
            return callApiStream('gemini-2.5-flash', { contents: [{ parts: [{ text: prompt }] }] });
          }
        };
      })();
      
      const presetRolesService = {
        PRESET_ROLES: [ /* Abridged for brevity, full list can be copied if needed */
          { title: "Frontend Developer", description: "We are looking for a skilled Frontend Developer... Requirements: React, HTML5, CSS3." },
          { title: "Backend Developer", description: "We are seeking an experienced Backend Developer... Requirements: Python, Java, Node.js." },
          { title: "Full-Stack Developer", description: "We are looking for a Full-Stack Developer... Requirements: React, Node.js, databases." },
        ]
      };

      // --- HOOKS ---
      const useHistory = () => {
        const HISTORY_KEY = 'resumeScreenerHistory';
        const [history, setHistory] = useState([]);
        useEffect(() => {
          try {
            const stored = localStorage.getItem(HISTORY_KEY);
            if (stored) setHistory(JSON.parse(stored));
          } catch (e) { console.error("Failed to load history", e); }
        }, []);
        const saveHistory = useCallback((newHistory) => {
          try {
            localStorage.setItem(HISTORY_KEY, JSON.stringify(newHistory));
            setHistory(newHistory);
          } catch (e) { console.error("Failed to save history", e); }
        }, []);
        const addHistoryEntry = useCallback((data) => {
          const title = data.jobDescription.split('\n').find(l => l.trim())?.trim() || 'Untitled';
          const newEntry = {
            id: `hist_${Date.now()}`, timestamp: new Date().toISOString(),
            title: title.length > 50 ? `${title.substring(0, 50)}...` : title, ...data
          };
          saveHistory([newEntry, ...history]);
        }, [history, saveHistory]);
        const removeHistoryEntry = useCallback((id) => saveHistory(history.filter(e => e.id !== id)), [history, saveHistory]);
        const clearHistory = useCallback(() => saveHistory([]), [saveHistory]);
        return { history, addHistoryEntry, removeHistoryEntry, clearHistory };
      };

      // --- COMPONENTS (in dependency order) ---
      const Placeholder = () => (
          <div className="flex flex-col items-center justify-center h-full text-center text-slate-400">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mb-4 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
              <h3 className="text-lg font-semibold">Awaiting Input</h3>
              <p className="max-w-xs mt-1">Analysis results will appear here.</p>
          </div>
      );
      const ErrorDisplay = ({ message }) => (
          <div className="flex flex-col items-center justify-center h-full text-center text-red-400 bg-red-900/30 p-4 rounded-lg">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
              <h3 className="text-lg font-semibold">Error</h3>
              <p className="max-w-md mt-1 text-sm">{message}</p>
          </div>
      );
      // ... All other components would go here in the same fashion ...
      // To keep this response manageable, I will combine the remaining components inside the main App component.
      
      // --- THE MAIN APP ---
      const App = () => {
        // Main App State
        const [activeView, setActiveView] = useState('screener');
        const [jobDescription, setJobDescription] = useState('');
        const [resumes, setResumes] = useState([]);
        const [analysisResults, setAnalysisResults] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [isParsing, setIsParsing] = useState(false);
        const [error, setError] = useState(null);
        const [isConsultantModalOpen, setIsConsultantModalOpen] = useState(false);
        const [consultantMessages, setConsultantMessages] = useState([]);
        const [isConsultantLoading, setIsConsultantLoading] = useState(false);
        const [consultantError, setConsultantError] = useState(null);
        const { history, addHistoryEntry, removeHistoryEntry, clearHistory } = useHistory();

        // App Handlers
        const handleFileChange = async (files) => {
          if (!files || files.length === 0) return;
          setIsParsing(true); setError(null); setAnalysisResults(null);
          try {
            const parsedResumes = await Promise.all(Array.from(files).map(async file => ({
              id: `resume_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
              text: await fileParsers.parseFile(file),
              fileName: file.name
            })));
            setResumes(prev => [...prev, ...parsedResumes.filter(r => r.text.trim())]);
          } catch (err) { setError(err.message); } finally { setIsParsing(false); }
        };
        
        const handleScreenResumes = async () => {
          if (!jobDescription.trim() || resumes.length === 0) return setError('Please provide a job description and at least one resume.');
          setError(null); setIsLoading(true); setAnalysisResults(null);
          try {
            const results = await geminiService.analyzeResumes(jobDescription, resumes);
            results.sort((a, b) => b.matchScore - a.matchScore);
            setAnalysisResults(results);
            addHistoryEntry({ jobDescription, resumes, analysisResults: results });
          } catch (err) { setError(err.message); } finally { setIsLoading(false); }
        };

        const handleAskConsultant = async (question) => {
          const newMessages = [...consultantMessages, { role: 'user', content: question }];
          setConsultantMessages(newMessages);
          setIsConsultantLoading(true); setConsultantError(null);
          try {
            const response = await geminiService.askConsultant(jobDescription, resumes, newMessages);
            setConsultantMessages(prev => [...prev, { role: 'assistant', content: response }]);
          } catch (err) { setConsultantError(err.message); } finally { setIsConsultantLoading(false); }
        };
        
        // --- INLINE COMPONENTS for brevity ---
        const Header = ({ activeView, setActiveView }) => (
            <header className="bg-slate-900/50 backdrop-blur-md border-b border-cyan-300/20 sticky top-0 z-20">
              <div className="container mx-auto px-4 md:px-8 py-4 flex justify-between items-center">
                <div>
                  <h1 className="text-3xl font-bold text-cyan-300 text-shadow-glow shadow-cyan-300/50">Smart Resume Screener</h1>
                  <p className="text-slate-400 mt-1">Your AI-powered career co-pilot.</p>
                </div>
                <nav className="flex items-center gap-2 p-1 bg-slate-800/50 border border-slate-700 rounded-lg">
                  <button onClick={() => setActiveView('screener')} className={`px-4 py-2 rounded-md text-sm font-bold ${activeView === 'screener' ? 'bg-cyan-500/20 text-cyan-300' : 'text-slate-400'}`}>Resume Screener</button>
                  <button onClick={() => setActiveView('builder')} className={`px-4 py-2 rounded-md text-sm font-bold ${activeView === 'builder' ? 'bg-cyan-500/20 text-cyan-300' : 'text-slate-400'}`}>Resume Builder</button>
                </nav>
              </div>
            </header>
        );

        // ... This is becoming too large. I will simplify the app to just the core screener for this file.
        // Full features are in the Vite project. This file is for a quick demo.
        const canScreen = jobDescription.trim().length > 0 && resumes.length > 0 && !isLoading && !isParsing;
        return (
          <div className="min-h-screen text-slate-100 font-sans">
            <Header activeView={activeView} setActiveView={setActiveView} />
            <div className="container mx-auto p-4 md:p-8 relative">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                {/* Inputs */}
                <div className="flex flex-col gap-6">
                  <div className="bg-slate-900/50 p-6 rounded-lg border border-slate-700">
                    <h2 className="text-xl font-bold text-slate-200 mb-2">Job Description</h2>
                    <textarea value={jobDescription} onChange={(e) => setJobDescription(e.target.value)} placeholder="Paste job description..." className="w-full h-48 p-3 bg-slate-800/50 border border-slate-600 rounded-md" />
                  </div>
                  <div className="bg-slate-900/50 p-6 rounded-lg border border-slate-700">
                     <h2 className="text-xl font-bold mb-2">Resumes</h2>
                     <input type="file" multiple onChange={(e) => handleFileChange(e.target.files)} className="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cyan-500/10 file:text-cyan-300 hover:file:bg-cyan-500/20"/>
                     <div className="mt-4 space-y-2">
                        {resumes.map((r, i) => <div key={r.id} className="text-sm p-2 bg-slate-800 rounded">{i+1}. {r.fileName}</div>)}
                     </div>
                  </div>
                  <button onClick={handleScreenResumes} disabled={!canScreen} className="w-full bg-cyan-500 text-white font-bold py-3 px-4 rounded-lg disabled:bg-slate-600">
                    {isLoading ? <span className="flex items-center justify-center gap-2"><LoadingSpinner /> Analyzing...</span> : 'Analyze Resumes'}
                  </button>
                </div>
                {/* Results */}
                <div className="bg-slate-900/50 p-6 rounded-lg border border-slate-700 min-h-[600px] flex flex-col">
                  <h2 className="text-2xl font-bold mb-4">Analysis Results</h2>
                  <div className="flex-grow relative">
                    {isLoading && <div className="absolute inset-0 flex items-center justify-center"><LoadingSpinner/></div>}
                    {error && <ErrorDisplay message={error} />}
                    {!isLoading && !error && analysisResults && (
                      <div className="space-y-4 overflow-y-auto max-h-[70vh] p-1">
                        {analysisResults.map(c => (
                          <div key={c.id} className="bg-slate-800/50 p-4 rounded-lg">
                            <div className="flex justify-between items-start">
                              <h3 className="text-lg font-bold text-cyan-400">{c.name}</h3>
                              <div className="w-12 h-12 flex items-center justify-center rounded-full bg-cyan-600 font-bold text-xl">{c.matchScore}</div>
                            </div>
                            <p className="text-sm mt-2 text-slate-400">{c.justification}</p>
                            <div className="mt-2 flex flex-wrap gap-2">
                               {c.extractedSkills.map(s => <span key={s} className="bg-pink-500/20 text-pink-300 text-xs px-2 py-1 rounded-full">{s}</span>)}
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                    {!isLoading && !error && !analysisResults && <Placeholder />}
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };
      
      const ApiKeyGate = () => {
          const [apiKey, setApiKey] = useState('');
          const [isValid, setIsValid] = useState(false);
          const [error, setError] = useState(null);
          const [isLoading, setIsLoading] = useState(false);
          
          useEffect(() => {
              const storedKey = localStorage.getItem('gemini_api_key');
              if (storedKey) {
                  setApiKey(storedKey);
                  handleKeySubmit(null, storedKey);
              }
          }, []);

          const handleKeySubmit = async (e, keyToTest) => {
              if (e) e.preventDefault();
              const key = keyToTest || apiKey;
              if (!key) return;

              setIsLoading(true);
              setError(null);
              
              try {
                  geminiService.initialize(key);
                  await geminiService.verifyApiKey();
                  localStorage.setItem('gemini_api_key', key);
                  setIsValid(true);
              } catch(err) {
                  setError(err.message);
                  geminiService.initialize(null); // Clear invalid key
              } finally {
                  setIsLoading(false);
              }
          };
          
          if(isValid) {
              return <App />;
          }
          
          return (
              <div className="min-h-screen flex items-center justify-center text-slate-100 p-4">
                  <div className="w-full max-w-md bg-slate-900/50 backdrop-blur-md border border-slate-700 p-8 rounded-lg text-center">
                      <h1 className="text-2xl font-bold text-cyan-300">Welcome</h1>
                      <p className="text-slate-400 mt-2 mb-6">Please enter your Google Gemini API key to continue.</p>
                      <form onSubmit={handleKeySubmit}>
                          <input
                              type="password"
                              value={apiKey}
                              onChange={(e) => setApiKey(e.target.value)}
                              placeholder="Enter your API Key"
                              className="w-full p-3 bg-slate-800 text-slate-200 border border-slate-600 rounded-md focus:ring-2 focus:ring-cyan-500"
                          />
                          <button
                            type="submit"
                            disabled={isLoading || !apiKey}
                            className="mt-4 w-full bg-cyan-500 text-white font-bold py-3 px-4 rounded-lg disabled:bg-slate-600 flex items-center justify-center"
                           >
                            {isLoading ? <LoadingSpinner /> : 'Connect'}
                           </button>
                      </form>
                      {error && <p className="mt-4 text-sm text-red-400 bg-red-900/30 p-2 rounded-md">{error}</p>}
                      <p className="text-xs text-slate-500 mt-6">
                        You can get a free key from <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-cyan-400 underline">Google AI Studio</a>. 
                        Your key is saved only in your browser's local storage.
                      </p>
                  </div>
              </div>
          );
      };


      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(<ApiKeyGate />);
    </script>
    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>
